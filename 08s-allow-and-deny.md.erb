---
title: 允许和拒绝
slug: allow-and-deny
date: 0008/01/02
number: 8.5
sidebar: true
contents: 研究回函调数的可执行行.|理解回函调数的可执行性顺序.
paragraphs: 16
---
Meteor 的安全系统不需要我们定义新的函数来控制数据库的修改。

当我们需要执行单独任务时，例如往新帖子上添加新特性，或者执行特定行为方程式， 这时我们需要定义一个具体的post方程。  

但在另一方面，我们不需要为修改帖子或删除特自定义新的方程。 我们只需要检查用户是否有权限执行这些方程， 这时我们就需要用到允许和拒绝回调函数。

这些回调函数让我们更具象地进行数据库修改。回调函数综合了用户系统， 这无疑是一大优质特征。

### 多样的回调函数

我们可以定义多个允许的回调函数。对于一个特定数据变化， 我们定义至少一个数值为真的回调函数。所以当浏览器访问Post.insert时， 服务器会自动寻找allowed-insert的数值为真的回调函数。如果这样的函数不存在，服务器不会允许insert，给用户回复403错误。

同样，我们可以定义一个或者多个拒绝的回调函数。如果其中一个回调函数数值为真，数据变化就会被取消，服务器回复403错误。一个成功的insert至少需要一个allow-insert回调函数的数值为真，需要所有deny-insert函数数值为假。

<%= diagram "allow_deny", "Note: n/e stands for Not Executed" %>

换一个说法， Meteor从拒绝回调函数开始逐一执行，然后允许回调函数，然后执行其他回调函数，知道其中一个函数的数值为真。

在实际用途里，我们可以建立两个allow()的回调函数，一个函数检查帖子是否属于当前用户，另外一个检查当前用户是有拥有管理权限。如果当前用户是管理员，那么至少有一个回调函数的数值为真，我们就能保证当前用户可以修改任何帖子。

### 延迟补偿

数据库的可变化方程（例如 .update)，就像其他方程一样，是可延迟补偿的。如果当你尝试从浏览器的控制台删除一个帖子， 你可以看到帖子短时间地消失， 但过一段时间帖子会重新出现，因为文件没有真正从后台删除。

这样的行为在控制台上不是问题（开发者可以随意支配数据进行开发）。但是，你需要确保这样的行为不会在用户端出现。比如说，你需要确保对于用户不能删除的帖子，用户不会看到删除键。

庆幸的是，你可以在客户端和服务端共享权限（例如，你可以写一个canDeletePost(user, post)方程，把它放在一个共享的 /lib路径里）。这样的构架并不麻烦。

### 服务端权限

权限系统只应用于发自客服端的数据库修改。在服务端，Meteor假定所有执行都是被允许的。

这意味着如果你构建了一个服务端 deletePost Meteor方程，而且这个方程可以被客户端执行，那么任何用户都可以删除任何帖子。因此如果需要检查权限，构建服务端 deletePost Meteor方程是不合理的。

### 使用拒绝的回调函数

最好，你可以用一个“onX”的回调函数进行拒绝。例如，你可以用以下代码实现lastModified timestamp:

~~~js
Posts.deny({
  update: function(userId, doc, fields, modifier) {
    doc.lastModified = +(new Date());
    return false;
  },
  transform: null
});
~~~
对于每次正确修改，当拒绝函数可以成功运行时，我们知道这个回调函数能够运行，能够结构性地修改文件。

这个技术自然有它地局限性，你也可以直接用一个方程进行修改。不管怎样，回调函数是一个值得理解的概念。我们希望将来软件包可以囊括 beforeUpdate 之类的回调函数。
